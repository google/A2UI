# What is A2UI?

**A2UI (Agent to UI) is a declarative UI protocol for agent-driven interfaces.** It enables AI agents to generate rich, interactive user interfaces that can be rendered natively across different platforms—web, mobile, and desktop—without executing arbitrary code.

Think of A2UI as a universal language for describing user interfaces that AI agents can speak fluently.

## The Problem: Agents Need to Speak UI

Imagine an agent designed to help you book a restaurant table. A text-only interaction might involve a clunky back-and-forth:

**User:** "Book a table for 2."
**Agent:** "Okay, for what day?"
**User:** "Tomorrow."
**Agent:** "What time?"
**User:** "Maybe 7pm"
**Agent:** "We do not have reservation availability then, any other times?"
**User:** "When do you have reservations?"
**Agent:** "We have availability at 5:00, 5:30, 6:00, 8:30, 9:00, 9:30 and 10:00. Do any of those work for you?"

This is slow and inefficient. A better experience would be for the **agent to generate** a simple form with a date picker, time selector, and submit button. With A2UI, LLMs can compose bespoke UIs from a catalog of widgets to provide a graphical, beautiful, easy-to-use interface for the exact task at hand.

## The Challenge: Rendering Across Trust Boundaries

We are entering the era of the multi-agent mesh. Agents from Google are talking to agents from Cisco, IBM, SAP, and Salesforce to solve complex tasks. This is why we collectively created the [Agent-to-Agent (A2A) Protocol](https://a2a-protocol.org) and donated it to the Linux Foundation: to enable agents to collaborate even when they don't share memory, tools, or context.

However, this decentralization creates a user interface problem.

If your agent lives inside your application, it can directly manipulate the view layer (e.g., DOM). But in a multi-agent world, the agent doing the work is often remote—running in the background, on a different server, or owned by a different organization. **It cannot touch your UI directly; it must send messages.**

Historically, rendering UI from a remote, untrusted source meant sending HTML or JavaScript and sandboxing it inside **iframes**. This approach is heavy, visually disjointed (it rarely matches your app's native styling), and introduces complexity around security boundaries.

**We needed a way to transmit UI that is safe like data, but expressive like code.**

## The Solution: UI as a Sequence of Messages

A2UI provides a standard format that can be:

- **Generated on the fly** as structured output by an LLM
- **Used as a template** and hydrated with values

The agent generating this response might be a remote A2A agent or the orchestrator the user is interacting with. The JSON payload can be sent to the client over A2A, AG UI, and potentially other transports.

**The client application renders using its own native UI components.** This means the client retains full control over styling and security, ensuring the agent's output always feels native to your app.

### Example: From Agent to UI

Here's how an agent describes a simple form in A2UI:

```json
{
  "createSurface": {
    "surfaceId": "booking",
    "catalogId": "https://a2ui.dev/specification/0.9/standard_catalog_definition.json"
  }
}
```

```json
{
  "updateComponents": {
    "surfaceId": "booking",
    "components": [
      {
        "id": "root",
        "Column": {
          "children": {"array": ["title", "date-picker", "submit-btn"]}
        }
      },
      {
        "id": "title",
        "Text": {
          "text": {"literal": "Book Your Table"},
          "style": "headline"
        }
      },
      {
        "id": "date-picker",
        "DatePicker": {
          "label": {"literal": "Select Date"},
          "value": {"path": "/booking/date"}
        }
      },
      {
        "id": "submit-btn",
        "Button": {
          "text": {"literal": "Confirm"},
          "onClick": {"actionId": "confirm_booking"}
        }
      }
    ]
  }
}
```

The client receives these JSON messages and renders them as native components—whether that's Angular on web, Flutter on mobile, or React on desktop.

## Core Value Propositions

### 1. Security: Data vs. Code

Running arbitrary code generated by an LLM presents significant security risks. **A2UI is a declarative data format, not executable code.**

Your client application maintains a "catalog" of trusted, pre-approved UI components (e.g., `Card`, `Button`, `TextField`), and the agent can only request to render components from that catalog. This reduces the risk of UI injection and other vulnerabilities.

**Traditional approach:**
```
Agent sends: <script>maliciousCode()</script>
Risk: Code execution vulnerability ⚠️
```

**A2UI approach:**
```
Agent sends: {"Button": {"text": "Click me"}}
Client: Checks catalog → Renders trusted Button component ✅
```

### 2. Native Feel: No iframes

Historically, rendering UI from a remote source meant sandboxing HTML/JavaScript in iframes. This creates problems:

- **Visual inconsistency**: Iframe UI doesn't inherit your app's styles
- **Performance overhead**: Each iframe is a separate document
- **Integration complexity**: Communication between iframe and host is cumbersome
- **Accessibility issues**: Screen readers struggle with nested iframes

A2UI takes a different approach: **the agent sends a blueprint of native components** that the client renders using its own UI framework.

This means the UI:
- Inherits your app's styling and theme
- Uses your app's accessibility features
- Performs like native UI (no iframe overhead)
- Integrates seamlessly with your app

### 3. Portability: Write Once, Render Anywhere

The A2UI protocol defines an abstract component tree. **One agent response works on web, Flutter, and native mobile.**

The client is responsible for mapping these abstract components to its native widget implementations:

- **Web**: Lit components, Angular components, React components
- **Mobile**: Flutter widgets, SwiftUI views (planned), Jetpack Compose (planned)
- **Desktop**: Flutter desktop, native desktop frameworks

The same JSON from an agent renders beautifully on every platform, with each platform's native look and feel.

```
                    ┌─────────────────┐
                    │  Agent sends    │
                    │  A2UI JSON      │
                    └────────┬────────┘
                             │
            ┌────────────────┼────────────────┐
            │                │                │
            ▼                ▼                ▼
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │   Angular   │  │   Flutter   │  │    React    │
    │  Component  │  │   Widget    │  │  Component  │
    └─────────────┘  └─────────────┘  └─────────────┘
```

## Design Principles

A2UI was designed around three key principles:

### 1. LLM-Friendly & Incrementally Updateable

The UI is represented as a **flat list of components with ID references**, which is easy for LLMs to generate incrementally.

**Traditional nested JSON:**
```json
{
  "type": "Column",
  "children": [
    {"type": "Text", "text": "Hello"},
    {"type": "Button", "text": "Click"}
  ]
}
```
Problem: LLM must generate perfect nesting in one pass.

**A2UI flat structure:**
```json
[
  {"id": "root", "Column": {"children": {"array": ["text1", "btn1"]}}},
  {"id": "text1", "Text": {"text": {"literal": "Hello"}}},
  {"id": "btn1", "Button": {"text": {"literal": "Click"}}}
]
```
Benefit: LLM can add components one at a time, correct mistakes, and stream incrementally.

### 2. Framework-Agnostic and Portable

A2UI separates the UI *structure* from the UI *implementation*.

The agent sends a description of the component tree and its associated data model. Your client application maps these abstract descriptions to its native widgets—be it web components, Flutter widgets, React components, SwiftUI views, or something else entirely.

### 3. Separation of Concerns

The protocol cleanly separates three layers:

1. **UI Structure** (components and layout)
2. **Application State** (data model)
3. **Client-Side Rendering** (widget implementation)

This separation enables powerful features:
- **Data binding**: Components automatically update when data changes
- **Reactive updates**: Change data, not structure, for dynamic UIs
- **Clean architecture**: Clear boundaries between agent and client

## What A2UI Is NOT

To clarify what A2UI is, it's helpful to understand what it's not:

- **Not a framework**: A2UI is a protocol. You use it with frameworks like AG UI, GenUI SDK, or your own app
- **Not a replacement for HTML**: A2UI is for agent-generated UIs, not hand-coded websites
- **Not a styling system**: The client controls all styling; agents describe structure, not appearance
- **Not a state management solution**: A2UI describes UI; you still need app logic and state management
- **Not limited to web**: Works on any platform with a renderer implementation

## Key Concepts

Before diving deeper, here are the core concepts:

- **Surface**: A canvas where components are rendered (like a dialog, sidebar, or main view)
- **Component**: A UI element (button, text field, card, etc.)
- **Data Model**: The application state that components bind to
- **Catalog**: The set of available component types
- **Message**: A JSON object describing a UI operation (create surface, update components, etc.)

## Next Steps

Now that you understand what A2UI is, explore:

- **[Who is A2UI for?](who-is-it-for.md)** - Understand if A2UI is right for your use case
- **[How can I use it?](how-to-use.md)** - Learn the different ways to integrate A2UI
- **[Where is it used?](where-is-it-used.md)** - See real-world examples and integrations
- **[Quickstart Guide](../quickstart.md)** - Get hands-on in 5 minutes
